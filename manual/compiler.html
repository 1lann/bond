<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Bond compiler</title>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #f8f8f8; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
pre, code { background-color: #f8f8f8; }
code > span.kw { color: #204a87; font-weight: bold; }
code > span.dt { color: #204a87; }
code > span.dv { color: #0000cf; }
code > span.bn { color: #0000cf; }
code > span.fl { color: #0000cf; }
code > span.ch { color: #4e9a06; }
code > span.st { color: #4e9a06; }
code > span.co { color: #8f5902; font-style: italic; }
code > span.ot { color: #8f5902; }
code > span.al { color: #ef2929; }
code > span.fu { color: #000000; }
code > span.er { font-weight: bold; }
  body {
      line-height: 1.5; 
      font-family: Helvetica, Arial, sans-serif; 
      color: #333333;
      font-size: 1em;
  }
  code {
      font-size: 1em;
      font-family: "Courier New", monospace, serif;
  }
  td.lineNumbers { width: 40px; }
  div#all {
    max-width: 1120px;
    background-color: #ffffff;
    margin: 0 auto;
    padding: 25px;
    overflow: auto;
  }
  code > span.co { color: #4E9A06; font-style: normal; }
  code > span.st { color: #8A0303; font-style: normal; }

  h1, h2, h3, h4, h5, h6 {
    font-weight: normal;
    border-bottom: 1px solid black;
  }

  div.sourceCode {
    overflow-x: auto;
  }

  #toc {
    width: 300px; 
    position:fixed;
    overflow: auto;
    height: 95%;
  }

  #main {
    margin-left: 320px;  
    margin-rigth: auto;
    max-width: 800px;
  }
  a {
    text-decoration: none;
  }
  #toc a:visited {
    color: #99c;
  }
  #main a:visited {
    color: #36c;
  }
  a:link {
    color: #36c;
  }
  @media screen and (max-width: 979px){
  #main {
    margin-left: auto;
    margin-right: auto;
  }
  #toc {
    left: -300px; 
  }
  }
  </style>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-58775439-1', 'auto');
  ga('send', 'pageview');

</script>
</head>
<body>
<nav id="TOC"></nav>
<div id="all">
<div id="toc">
<ul>
<li><a href="#command-line-options">Command line options</a></li>
<li><a href="#idl-syntax">IDL syntax</a><ul>
<li><a href="#import-statements">Import statements</a></li>
<li><a href="#namespace-definition">Namespace definition</a></li>
<li><a href="#enum-definition">Enum definition</a></li>
<li><a href="#forward-declaration">Forward declaration</a></li>
<li><a href="#struct-definition">Struct definition</a></li>
<li><a href="#generics">Generics</a></li>
<li><a href="#type-aliases">Type aliases</a></li>
<li><a href="#struct-views">Struct views</a></li>
<li><a href="#custom-attributes">Custom attributes</a></li>
<li><a href="#comments">Comments</a></li>
</ul></li>
<li><a href="#schema-ast">Schema AST</a><ul>
<li><a href="#import">Import</a></li>
<li><a href="#namespace">Namespace</a></li>
<li><a href="#declaration">Declaration</a><ul>
<li><a href="#struct">Struct</a></li>
<li><a href="#enum">Enum</a></li>
<li><a href="#type-alias">Type alias</a></li>
<li><a href="#forward-declaration-1">Forward declaration</a></li>
</ul></li>
<li><a href="#qualified-name">Qualified name</a></li>
<li><a href="#type-parameter">Type parameter</a></li>
<li><a href="#attribute">Attribute</a></li>
<li><a href="#struct-field">Struct field</a><ul>
<li><a href="#field-default-value">Field default value</a></li>
</ul></li>
<li><a href="#type">Type</a><ul>
<li><a href="#basic-types">Basic types</a></li>
<li><a href="#complex-types">Complex types</a></li>
</ul></li>
</ul></li>
</ul>
</div>
<div id="main">
<div id="header">    
<h1 class="title">Bond compiler</h1>
</div>
<h1 id="command-line-options">Command line options</h1>
<div class="sourceCode">
<object width="702" height="1000" data="gbc.html"></object>
</div>
<h1 id="idl-syntax">IDL syntax</h1>
<p>A Bond schema definition file can contain the following elements:</p>
<ul>
<li>Import statements</li>
<li>Namespace definition</li>
<li>Declarations
<ul>
<li>enum</li>
<li>forward declaration</li>
<li>struct</li>
<li>generics</li>
<li>struct view</li>
</ul></li>
<li>Custom attributes</li>
<li>Comments</li>
</ul>
<h2 id="import-statements">Import statements</h2>
<p>In order to use types defined in another schema definition file, the other file needs to be explicitly imported. Schema file can contain zero or more import statements and they must appear at the top of the file:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">import <span class="st">&quot;file.bond&quot;</span></code></pre></div>
<p>The file being imported can be specified using a partial path which is resolved by Bond compiler relative to the directory containing the schema file being compiled and any import path(s) specified using the –import-dir option(s) passed to gbc.</p>
<p>See examples:</p>
<ul>
<li><code>examples/cpp/core/import</code></li>
<li><code>examples/cs/core/import</code></li>
</ul>
<h2 id="namespace-definition">Namespace definition</h2>
<p>All schema types are always defined within a namespace. Namespace scope starts with namespace definition statement and ends at the end of the file.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> some.unique.name</code></pre></div>
<h2 id="enum-definition">Enum definition</h2>
<p>Bond enums are very similar to C++ enums, both in semantics and syntax used to define them:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">enum</span> Protocols
{
    TCP,
    UDP = <span class="dv">10</span>
}</code></pre></div>
<p>On the wire values of enums types are equivalent to 32-bit signed integers.</p>
<h2 id="forward-declaration">Forward declaration</h2>
<p>In order to define recursive schemas, such as trees, it may be necessary to declare a struct before it is defined. A forward declaration statement serves this purpose:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Node;</code></pre></div>
<p>Forward declared structs can be used in field declarations as the base type for nullable&lt;T&gt; and bonded&lt;T&gt; or the element type of a container.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Node;

<span class="kw">struct</span> Node
{
    <span class="dv">0</span>: nullable&lt;Node&gt; left;
    <span class="dv">1</span>: nullable&lt;Node&gt; right;
}</code></pre></div>
<h2 id="struct-definition">Struct definition</h2>
<p>Struct definition consists of a struct name, an optional base struct, and zero or more fields.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Example : Base
{
    <span class="dv">0</span>: uint32 fieldName = <span class="dv">10</span>;
}</code></pre></div>
<p>Field definition consists of an ordinal, type, name and optional default value. Field type can be:</p>
<ul>
<li><p>Basic type: <code>bool</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>float</code>, <code>double</code>, <code>string</code>, <code>wstring</code>.</p></li>
<li><p>Container: <code>blob</code>, <code>list&lt;T&gt;</code>, <code>vector&lt;T&gt;</code>, <code>set&lt;T&gt;</code>, <code>map&lt;K, T&gt;</code>, <code>nullable&lt;T&gt;</code>.</p></li>
<li><p>User-defined type: enum, struct or <code>bonded&lt;T&gt;</code> where T is a struct.</p></li>
</ul>
<p>An optional default value can be specified for fields of basic types. For integers the default can be specified as either a decimal number or a hexadecimal number prefixed with <code>0x</code>. The only explicit default value allowed for containers is <a href="#default-value-of-nothing"><code>nothing</code></a>. Enum fields must have an explicit default value which must be one of the enum named constants.</p>
<p>Names of structs and enums defined in another namespace must be qualified with the namespace name:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">import <span class="st">&quot;bond/core/bond.bond&quot;</span>

<span class="kw">namespace</span> example

<span class="kw">struct</span> Example
{
    <span class="dv">0</span>: bond.GUID id;
    <span class="dv">1</span>: bond.BondDataType type = BT_UNAVAILABLE;
}</code></pre></div>
<h2 id="generics">Generics</h2>
<p>Generic structs are parameterized with one or more type parameters which can be used within the struct definition in any place where a concrete type could be used (e.g. base struct, field type, container element type, parameter of a generic struct).</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Example&lt;T1, T2&gt; : T1
{
    <span class="dv">0</span>: T1 field;
    <span class="dv">1</span>: list&lt;T2&gt; list;
    <span class="dv">2</span>: Generic&lt;T2&gt; generic;
}</code></pre></div>
<p>Usage of a type parameter within a generic struct definition may implicitly constrain what type(s) can be used to instantiate the generic struct:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Example&lt;T&gt;
{
    <span class="co">// The default value of 10 implicitly constrains T to numeric types</span>
    <span class="dv">0</span>: T x = <span class="dv">10</span>;
}</code></pre></div>
<p>Using a type parameter in a <a href="#nullable-types"><code>nullable</code></a> or as the type of a field with default value of <a href="#default-value-of-nothing"><code>nothing</code></a> constrains the type parameter to be non-scalar type. If this is undesired then explicit constraint to value type can be specified in the generic schema definition:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Example&lt;T : value&gt;
{
    <span class="dv">0</span>: nullable&lt;T&gt; x;
    <span class="dv">1</span>: T y = nothing;
}</code></pre></div>
<p>When instantiating a generic struct all type parameters must be concrete types. Bond IDL doesn’t support the equivalent of C++ template template parameters.</p>
<p>See examples:</p>
<ul>
<li><code>examples/cpp/core/generics</code></li>
<li><code>examples/cs/core/generics</code></li>
<li><code>examples/cpp/core/generic_tree</code></li>
</ul>
<h2 id="type-aliases">Type aliases</h2>
<p>The syntax to define type aliases is very similar to C++:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> time = int64;
<span class="kw">using</span> array&lt;T&gt; = vector&lt;T&gt;;</code></pre></div>
<p>An alias can be used in any context where the aliased type could be used, including a definition of another alias:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> times = array&lt;time&gt;;</code></pre></div>
<p>Type aliases can optionally be <a href="#custom-type-mappings">mapped to custom types</a> in the generated code.</p>
<p>See examples:</p>
<ul>
<li><code>examples/cpp/core/time_alias</code></li>
<li><code>examples/cpp/core/multiprecision</code></li>
<li><code>examples/cpp/core/string_ref</code></li>
<li><code>examples/cpp/core/container_of_pointers</code></li>
<li><code>examples/cpp/core/static_array</code></li>
<li><code>examples/cs/core/date_time</code></li>
<li><code>examples/cs/core/decimal</code></li>
<li><code>examples/cs/core/guid</code></li>
<li><code>examples/cs/core/container_alias</code></li>
</ul>
<h2 id="struct-views">Struct views</h2>
<p>A view definition is syntactic sugar to define a struct that has a subset of the fields of another struct:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Example
{
    <span class="dv">0</span>: int16 x;
    <span class="dv">1</span>: string y;
    <span class="dv">2</span>: list&lt;<span class="dt">bool</span>&gt; z;
}

<span class="kw">struct</span> View view_of Example
{
    x,z;
}</code></pre></div>
<p>In the above example, the definition of <code>View</code> is equivalent to:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> View
{
    <span class="dv">0</span>: int16 x;
    <span class="dv">2</span>: list&lt;<span class="dt">bool</span>&gt; z;
}</code></pre></div>
<p>A view of a generic struct is also a generic struct with the same number of type parameters.</p>
<p>A view of a sealed struct is always sealed. A view of non-sealed struct can be defined to be sealed:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">sealed <span class="kw">struct</span> View view_of Example
{
    x,
    z;
}</code></pre></div>
<p>See example: <code>examples/cpp/core/schema_view</code></p>
<h2 id="custom-attributes">Custom attributes</h2>
<p>Struct, enum and field definitions can be annotated with custom attributes which are in effect name, string-values pairs:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">[Validate(<span class="st">&quot;True&quot;</span>)]
<span class="kw">struct</span> Example
{
    [Max(<span class="st">&quot;100&quot;</span>)]
    <span class="dv">0</span>: uint32 value;
}</code></pre></div>
<p>Attributes are available in code generation templates and thus can be used to drive custom code generation. They are also available to applications via <a href="#compile-time-schema">compile-time</a> and <a href="#runtime-schema">runtime</a> schema, and as <code>Metadata</code> argument in <a href="#transforms">transforms</a> and <a href="#protocols">protocols</a>.</p>
<p>See example: <code>examples/cpp/core/attributes</code></p>
<h2 id="comments">Comments</h2>
<p>Bond IDL supports C++ style comments:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/*</span>
<span class="co">    Multi-line </span>
<span class="co">    comment</span>
<span class="co">*/</span>
<span class="kw">struct</span> Example
{
    <span class="co">// One line comment</span>
}</code></pre></div>
<h1 id="schema-ast">Schema AST</h1>
<p>The compiler exposes a JSON representation of the schema Abstract Syntax Tree. The AST is intended for tools that need to access to the schema information contained in Bond IDL files with the full fidelity. The compiler can also take the JSON representation of the AST as an input, enabling tools which programmatically construct/modify Bond schemas.</p>
<p>The top level JSON object represents the parsed Bond IDL file and has the following structure:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;imports&quot;</span>: [
  ],
  <span class="st">&quot;namespaces&quot;</span>: [
  ],
  <span class="st">&quot;declarations&quot;</span>: [
  ]
}</code></pre></div>
<h2 id="import">Import</h2>
<p>Imports are represented by JSON strings. For example the following IDL:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">import <span class="st">&quot;bond/core/bond.bond&quot;</span></code></pre></div>
<p>is represented in the AST as:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="st">&quot;bond/core/bond.bond&quot;</span></code></pre></div>
<h2 id="namespace">Namespace</h2>
<p>Each Bond file should have one namespace declaration, although the AST and IDL syntax have support for legacy schema files with multiple, language-specific namespaces. The namespace declaration is represented by a JSON object:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;name&quot;</span>: [
  ]
}</code></pre></div>
<p>where:</p>
<ul>
<li><code>name</code> is <a href="#qualified-name">qualified name</a> of the namespace.</li>
</ul>
<h2 id="declaration">Declaration</h2>
<p>A declaration is represented by a JSON object with the following common properties:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;tag&quot;</span>: <span class="st">&quot;Tag&quot;</span>,
  <span class="st">&quot;declNamespaces&quot;</span>: [
  ],
  <span class="st">&quot;declName&quot;</span>: <span class="st">&quot;Name&quot;</span>,
  <span class="st">&quot;declParams&quot;</span>: [
  ],
  <span class="st">&quot;declAttributes&quot;</span>: [
  ]
}</code></pre></div>
<p>where:</p>
<ul>
<li><code>tag</code> is a string indicating the type of the declaration. It can have one of the following values: <code>&quot;Struct&quot;</code>, <code>&quot;Enum&quot;</code>, <code>&quot;Alias&quot;</code>, <code>&quot;Forward&quot;</code>.</li>
<li><code>declNamespaces</code> is an array of one or more <a href="#namespace">namespaces</a>.</li>
<li><code>declName</code> is a string.</li>
<li><code>declParams</code> is an array of zero or more <a href="#type-parameter">type parameters</a>. The property doesn’t apply to <a href="#enum"><code>Enum</code></a> declarations.</li>
<li><code>declAttributes</code> is an array of zero or more <a href="#attribute">attributes</a>. The property doesn’t apply to <a href="#forward-declaration"><code>Forward</code></a> declarations.</li>
</ul>
<h3 id="struct">Struct</h3>
<p>A JSON object representing a <code>Struct</code> declaration has the following properties:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;tag&quot;</span>: <span class="st">&quot;Struct&quot;</span>,
  <span class="st">&quot;declNamespaces&quot;</span>: [
  ],
  <span class="st">&quot;declName&quot;</span>: <span class="st">&quot;Name&quot;</span>,
  <span class="st">&quot;declParams&quot;</span>: [
  ],
  <span class="st">&quot;declAttributes&quot;</span>: [
  ],
  <span class="st">&quot;structBase&quot;</span>: null,
  <span class="st">&quot;structFields&quot;</span>: [
  ]
}</code></pre></div>
<p>where:</p>
<ul>
<li><code>structBase</code> is <code>null</code> or a <a href="#type">type</a> representing the struct base. The property is optional and may be omitted.</li>
<li><code>structFields</code> is an array of zero or more <a href="#struct-field">fields</a>.</li>
</ul>
<h3 id="enum">Enum</h3>
<p>A JSON object representing an <code>Enum</code> declaration has the following properties:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;tag&quot;</span>: <span class="st">&quot;Enum&quot;</span>,
  <span class="st">&quot;declNamespaces&quot;</span>: [
  ],
  <span class="st">&quot;declName&quot;</span>: <span class="st">&quot;Name&quot;</span>,
  <span class="st">&quot;declAttributes&quot;</span>: [
  ],
  <span class="st">&quot;enumConstants&quot;</span>: [
  ]
}</code></pre></div>
<p>where:</p>
<ul>
<li><code>enumConstants</code> is an array of one or more <a href="#constant">constants</a>.</li>
</ul>
<h4 id="constant">Constant</h4>
<p>An enum constant is represented by the following JSON object:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;constantName&quot;</span>: <span class="st">&quot;Name&quot;</span>,
  <span class="st">&quot;constantValue&quot;</span>: null
}</code></pre></div>
<p>where:</p>
<ul>
<li><code>constantName</code> is a string.</li>
<li><code>constantValue</code> is an integer or <code>null</code> if the value is not explicitly defined. The property is optional and may be omitted.</li>
</ul>
<h3 id="type-alias">Type alias</h3>
<p>A JSON object representing a type alias declaration has the following properties:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;tag&quot;</span>: <span class="st">&quot;Alias&quot;</span>,
  <span class="st">&quot;declNamespaces&quot;</span>: [
  ],
  <span class="st">&quot;declName&quot;</span>: <span class="st">&quot;Name&quot;</span>,
  <span class="st">&quot;declParams&quot;</span>: [
  ],
  <span class="st">&quot;aliasType&quot;</span>: {
  }
}</code></pre></div>
<p>where:</p>
<ul>
<li><code>aliasType</code> is the aliased <a href="#type"><code>type</code></a>.</li>
</ul>
<h3 id="forward-declaration-1">Forward declaration</h3>
<p>A JSON object representing a forward declaration has the following properties:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;tag&quot;</span>: <span class="st">&quot;Forward&quot;</span>,
  <span class="st">&quot;declNamespaces&quot;</span>: [
  ],
  <span class="st">&quot;declName&quot;</span>: <span class="st">&quot;Name&quot;</span>,
  <span class="st">&quot;declParams&quot;</span>: [
  ]
}</code></pre></div>
<h2 id="qualified-name">Qualified name</h2>
<p>Qualified names are represented in JSON by an array of strings. For example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">foo.bar</code></pre></div>
<p>is represented by:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">[ <span class="st">&quot;foo&quot;</span>,
  <span class="st">&quot;bar&quot;</span>
]</code></pre></div>
<h2 id="type-parameter">Type parameter</h2>
<p>Type parameters are represented by JSON objects with the following properties:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;paramName&quot;</span>: <span class="st">&quot;T&quot;</span>,
  <span class="st">&quot;paramConstraint&quot;</span>: null
}</code></pre></div>
<p>where:</p>
<ul>
<li><code>paramName</code> is a string.</li>
<li><code>paramConstraint</code> is <code>null</code> or the string <code>&quot;value&quot;</code>. The property is optional and may be omitted.</li>
</ul>
<h2 id="attribute">Attribute</h2>
<p>Attributes are represented by JSON objects with the following properties:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;attrName&quot;</span>: [
  ],
  <span class="st">&quot;attrValue&quot;</span>: <span class="st">&quot;Value&quot;</span>
}</code></pre></div>
<p>where:</p>
<ul>
<li><code>attrName</code> is a <a href="#qualified-name">qualified name</a>.</li>
<li><code>attrValue</code> is a string.</li>
</ul>
<h2 id="struct-field">Struct field</h2>
<p>A struct field is represented by a JSON object with the following properties:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;fieldModifier&quot;</span>: <span class="st">&quot;Optional&quot;</span>,
  <span class="st">&quot;fieldDefault&quot;</span>: null,
  <span class="st">&quot;fieldType&quot;</span>: {
  },
  <span class="st">&quot;fieldName&quot;</span>: <span class="st">&quot;name&quot;</span>,
  <span class="st">&quot;fieldAttributes&quot;</span>: [
  ],
  <span class="st">&quot;fieldOrdinal&quot;</span>: <span class="dv">0</span>
}</code></pre></div>
<p>where:</p>
<ul>
<li><code>fieldModifier</code> is one of the following strings: <code>&quot;Optional&quot;</code>, <code>&quot;Required&quot;</code>, <code>&quot;RequiredOptional&quot;</code>.</li>
<li><code>fieldDefault</code> is <code>null</code> or a <a href="#field-default-value">default value</a>. The property is optional and may be omitted.</li>
<li><code>fieldType</code> is a <a href="#type">type</a>.</li>
<li><code>fieldName</code> is a string.</li>
<li><code>fieldAttributes</code> is an array of zero or more <a href="#attribute">attributes</a>.</li>
<li><code>fieldOrdinal</code> is an integer.</li>
</ul>
<h3 id="field-default-value">Field default value</h3>
<p>A field default value is represented by a JSON object with the following properties:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;type&quot;</span>: <span class="st">&quot;enum&quot;</span>,
  <span class="st">&quot;value&quot;</span>: <span class="st">&quot;Value2&quot;</span>
}</code></pre></div>
<p>where:</p>
<ul>
<li><code>type</code> is one of the following strings: <code>&quot;enum&quot;</code>, <code>&quot;bool&quot;</code>, <code>&quot;integer&quot;</code>, <code>&quot;float&quot;</code>, <code>&quot;string&quot;</code>, <code>&quot;nothing&quot;</code>.</li>
<li><code>value</code> is a value appropriate for the type. The <code>value</code> property is not used when <code>type</code> is <code>&quot;nothing&quot;</code>.</li>
</ul>
<h2 id="type">Type</h2>
<h3 id="basic-types">Basic types</h3>
<p>Basic types are represented by JSON strings:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="st">&quot;int8&quot;</span>
<span class="st">&quot;int16&quot;</span>
<span class="st">&quot;int32&quot;</span>
<span class="st">&quot;int64&quot;</span>
<span class="st">&quot;uint8&quot;</span>
<span class="st">&quot;uint16&quot;</span>
<span class="st">&quot;uint32&quot;</span>
<span class="st">&quot;uint64&quot;</span>
<span class="st">&quot;float&quot;</span>
<span class="st">&quot;double&quot;</span>
<span class="st">&quot;bool&quot;</span>
<span class="st">&quot;string&quot;</span>
<span class="st">&quot;wstring&quot;</span>
<span class="st">&quot;blob&quot;</span></code></pre></div>
<h3 id="complex-types">Complex types</h3>
<p>Complex types are represented by JSON objects with a <code>type</code> property indicating the complex type. If the <code>type</code> property is one of the following: <code>&quot;vector&quot;</code>, <code>&quot;list&quot;</code>, <code>&quot;set&quot;</code>, <code>&quot;nullable&quot;</code>, <code>&quot;maybe&quot;</code>, <code>&quot;bonded&quot;</code> then the object has the following structure:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;type&quot;</span>: <span class="st">&quot;vector&quot;</span>,
  <span class="st">&quot;element&quot;</span>: {
  }
}</code></pre></div>
<p>where <code>element</code> is the <a href="#type">type</a> of the element (or the nested type).</p>
<p>Other complex types are:</p>
<ul>
<li><p>map</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;type&quot;</span>: <span class="st">&quot;map&quot;</span>,
  <span class="st">&quot;key&quot;</span>: {
  },
  <span class="st">&quot;element&quot;</span>: {
  }
}</code></pre></div>
<p>where:</p>
<ul>
<li><code>key</code> is the <a href="#type">type</a> of the map key.</li>
<li><code>element</code> is the <a href="#type">type</a> of map value.</li>
</ul></li>
<li><p>type parameter</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;type&quot;</span>: <span class="st">&quot;parameter&quot;</span>,
  <span class="st">&quot;value&quot;</span>: {
  }
}</code></pre></div>
<p>where <code>value</code> is a <a href="#type-parameter">type parameter</a>.</p></li>
<li><p>numeric type argument</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;type&quot;</span>: <span class="st">&quot;constant,</span>
  <span class="st">&quot;value&quot;</span>: <span class="dv">0</span>
}</code></pre></div>
<p>where <code>value</code> is an integer.</p></li>
<li><p>user defined type</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;type&quot;</span>: <span class="st">&quot;user&quot;</span>,
  <span class="st">&quot;declaration&quot;</span>: {
  },
  <span class="st">&quot;arguments&quot;</span>: [
  ]
}</code></pre></div>
<p>where:</p>
<ul>
<li><code>declaration</code> is a <a href="#declaration">declaration</a> of a user defined type.</li>
<li><code>arguments</code> is an array of zero or more <a href="#type">types</a> representing type arguments for a generic user defined type. The property is optional and may be omitted for non-generic types.</li>
</ul></li>
</ul>
</div>    
</div>
</body>
</html>
