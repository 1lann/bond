<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>A Young Person’s Guide to C# Bond</title>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #f8f8f8; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
pre, code { background-color: #f8f8f8; }
code > span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code > span.dt { color: #204a87; } /* DataType */
code > span.dv { color: #0000cf; } /* DecVal */
code > span.bn { color: #0000cf; } /* BaseN */
code > span.fl { color: #0000cf; } /* Float */
code > span.ch { color: #4e9a06; } /* Char */
code > span.st { color: #4e9a06; } /* String */
code > span.co { color: #8f5902; font-style: italic; } /* Comment */
code > span.ot { color: #8f5902; } /* Other */
code > span.al { color: #ef2929; } /* Alert */
code > span.fu { color: #000000; } /* Function */
code > span.er { color: #a40000; font-weight: bold; } /* Error */
code > span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #000000; } /* Constant */
code > span.sc { color: #000000; } /* SpecialChar */
code > span.vs { color: #4e9a06; } /* VerbatimString */
code > span.ss { color: #4e9a06; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #000000; } /* Variable */
code > span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code > span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code > span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code > span.ex { } /* Extension */
code > span.at { color: #c4a000; } /* Attribute */
code > span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code > span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
  body {
      line-height: 1.5; 
      font-family: Helvetica, Arial, sans-serif; 
      color: #333333;
      font-size: 1em;
  }
  code {
      font-size: 1em;
      font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace, serif;
  }
  td.lineNumbers { width: 40px; }
  div#all {
    max-width: 1120px;
    background-color: #ffffff;
    margin: 0 auto;
    padding: 25px;
    overflow: auto;
  }
  code > span.kw { color: #204a87; font-weight: normal; } /* Keyword */  
  code > span.co { color: #4E9A06; font-style: normal; }
  code > span.st { color: #8A0303; font-style: normal; }
  code > span.cf { color: #204a87; font-weight: normal; } /* ControlFlow */
  code > span.op { color: #000000; font-weight: normal; } /* Operator */
  code > span.pp { color: #8f5902; font-style: normal; } /* Preprocessor */
  code > span.ex { } /* Extension */
  code > span.at { color: #c4a000; } /* Attribute */
  code > span.do { color: #8f5902; font-weight: normal; font-style: normal; } /* Documentation */
  code > span.an { color: #8f5902; font-weight: normal; font-style: normal; } /* Annotation */
  code > span.cv { color: #8f5902; font-weight: normal; font-style: normal; } /* CommentVar */
  code > span.in { color: #8f5902; font-weight: normal; font-style: normal; } /* Information */

  h1, h2, h3, h4, h5, h6 {
    font-weight: normal;
    border-bottom: 1px solid black;
  }

  div.sourceCode {
    overflow-x: auto;
  }

  table.sourceCode { 
    line-height: 120%;
  } 

  #toc {
    width: 300px; 
    position:fixed;
    overflow: auto;
    height: 95%;
  }

  #main {
    margin-left: 320px;  
    margin-rigth: auto;
    max-width: 800px;
  }
  a {
    text-decoration: none;
  }
  #toc a:visited {
    color: #99c;
  }
  #main a:visited {
    color: #36c;
  }
  a:link {
    color: #36c;
  }
  @media screen and (max-width: 979px){
  #main {
    margin-left: auto;
    margin-right: auto;
  }
  #toc {
    left: -300px; 
  }
  }
  </style>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-58775439-1', 'auto');
  ga('send', 'pageview');

</script>
</head>
<body>
<nav id="TOC"></nav>
<div id="all">
<div id="toc">
<ul>
<li><a href="#about">About</a></li>
<li><a href="#basic-example">Basic example</a></li>
<li><a href="#code-generation">Code generation</a></li>
<li><a href="#serializer">Serializer</a></li>
<li><a href="#deserializer">Deserializer</a></li>
<li><a href="#marshaling">Marshaling</a></li>
<li><a href="#transcoder">Transcoder</a></li>
<li><a href="#input-and-output-streams">Input and output streams</a></li>
<li><a href="#cloner">Cloner</a></li>
<li><a href="#comparer">Comparer</a></li>
<li><a href="#performance">Performance</a></li>
<li><a href="#runtime-schema">Runtime schema</a></li>
<li><a href="#understanding-bondedt">Understanding <code>bonded&lt;T&gt;</code></a><ul>
<li><a href="#lazy-deserialization">Lazy deserialization</a></li>
<li><a href="#pass-through">Pass-through</a></li>
<li><a href="#polymorphism">Polymorphism</a></li>
</ul></li>
<li><a href="#custom-type-mappings">Custom type mappings</a><ul>
<li><a href="#codegen-parameters">Codegen parameters</a></li>
<li><a href="#custom-containers">Custom containers</a></li>
<li><a href="#converter">Converter</a></li>
</ul></li>
<li><a href="#xml">Xml</a></li>
<li><a href="#json">JSON</a></li>
<li><a href="#attributes">Attributes</a><ul>
<li><a href="#schema-decoration">Schema decoration</a><ul>
<li><a href="#schemaattribute">SchemaAttribute</a></li>
<li><a href="#namespaceattribute">NamespaceAttribute</a></li>
<li><a href="#idattribute">IdAttribute</a></li>
<li><a href="#requiredattribute">RequiredAttribute</a></li>
<li><a href="#typeattribute">TypeAttribute</a></li>
<li><a href="#defaultattribute">DefaultAttribute</a></li>
<li><a href="#attributeattribute">AttributeAttribute</a></li>
</ul></li>
<li><a href="#protocol-decoration">Protocol decoration</a><ul>
<li><a href="#readerattribute">ReaderAttribute</a></li>
<li><a href="#parserattribute">ParserAttribute</a></li>
<li><a href="#serializerattribute">SerializerAttribute</a></li>
</ul></li>
</ul></li>
<li><a href="#references">References</a><ul>
<li><a href="#bond-compiler-referencecompiler"><a href="compiler.html">Bond compiler reference</a></a></li>
<li><a href="#c-users-manualbond_cpp"><a href="bond_cpp.html">C++ User’s Manual</a></a></li>
<li><a href="#python-users-manualbond_py"><a href="bond_py.html">Python User’s Manual</a></a></li>
</ul></li>
</ul>
</div>
<div id="main">
<div id="header">    
<h1 class="title">A Young Person’s Guide to C# Bond</h1>
</div>
<h1 id="about">About</h1>
<p>Bond is an extensible framework for working with schematized data. It is suitable for scenarios ranging from service communications to Big Data storage and processing.</p>
<p>Bond defines a rich type system and schema versioning rules which allow forward and backward compatibility. The core Bond features include high performance serialization/deserialization and a very powerful, generic data transform mechanism. The framework is highly extensible via pluggable serialization protocols, data streams, user defined type aliases and more.</p>
<p>By design Bond is language and platform independent and is currently supported for C++, C#, and Python on Linux, OS X and Windows.</p>
<p>Bond is published on GitHub at <a href="https://github.com/Microsoft/bond/" class="uri">https://github.com/Microsoft/bond/</a>.</p>
<h1 id="basic-example">Basic example</h1>
<p>In Bond data schemas are defined using idl-like <a href="compiler.html#idl-syntax">syntax</a>:</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs"><span class="kw">namespace</span> Examples

<span class="kw">struct</span> Record
{
    <span class="dv">0</span>: <span class="dt">string</span> Name;
    <span class="dv">1</span>: vector&lt;<span class="dt">double</span>&gt; Constants;
}</code></pre></td></tr></table></div>
<p>In order to use the schema in a C# program, it needs to be compiled using the Bond compiler. This step is sometimes also referred to as code generation (or codegen) because the compilation generates C# code corresponding to the schema definition.</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs">gbc c# example.<span class="fu">bond</span></code></pre></td></tr></table></div>
<p>Using the generated C# code, we can write a simple program that will serialize and deserialize an instance of the Record schema using <a href="bond_cpp.html#compact-binary">Compact Binary</a> protocol:</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs"><span class="kw">namespace</span> Examples
{
    <span class="kw">using</span> Bond;
    <span class="kw">using</span> Bond.<span class="fu">Protocols</span>;
    <span class="kw">using</span> Bond.<span class="fu">IO</span>.<span class="fu">Safe</span>;

    <span class="kw">class</span> Program
    {
        <span class="kw">static</span> <span class="dt">void</span> <span class="fu">Main</span>()
        {
            <span class="dt">var</span> src = <span class="kw">new</span> Record
            {
                Name = <span class="st">&quot;FooBar&quot;</span>,
                Constants = { <span class="fl">3.14</span>, <span class="fl">6.28</span> }
            };

            <span class="dt">var</span> output = <span class="kw">new</span> <span class="fu">OutputBuffer</span>();
            <span class="dt">var</span> writer = <span class="kw">new</span> CompactBinaryWriter&lt;OutputBuffer&gt;(output);

            <span class="co">// The first calls to Serialize.To and Deserialize&lt;T&gt;.From can take</span>
            <span class="co">// a relatively long time because they generate the de/serializer </span>
            <span class="co">// for a given type and protocol.</span>
            Serialize.<span class="fu">To</span>(writer, src);

            <span class="dt">var</span> input = <span class="kw">new</span> <span class="fu">InputBuffer</span>(output.<span class="fu">Data</span>);
            <span class="dt">var</span> reader = <span class="kw">new</span> CompactBinaryReader&lt;InputBuffer&gt;(input);

            <span class="dt">var</span> dst = Deserialize&lt;Record&gt;.<span class="fu">From</span>(reader);
        }
    }
}</code></pre></td></tr></table></div>
<h1 id="code-generation">Code generation</h1>
<p>In order to use a Bond schema in a C# program, it needs to be compiled using the Bond compiler <a href="compiler.html"><code>gbc</code></a>. The compiler generates C# classes that represent the schema. By default schema fields are represented by public auto-properties initialized in the default constructor. Code generation can be customized by passing one or more of the following command line options to <code>gbc</code>:</p>
<p><code>--fields</code></p>
<p>Schema fields are represented by public fields with initializers and no constructor is generated.</p>
<p><code>--readonly-properties</code></p>
<p>Schema fields are represented by properties with public getter and private setter and initialized to the default values in the default constructor. Classes with read-only properties are fully supported by all Bond APIs.</p>
<p><code>--collection-interfaces</code></p>
<p>Collection types <code>vector&lt;T&gt;</code>, <code>map&lt;K, V&gt;</code>, <code>list&lt;T&gt;</code> and <code>set&lt;T&gt;</code> are represented by respective generic collection interfaces: <code>IList&lt;T&gt;</code>, <code>IDictionary&lt;K, V&gt;</code>, <code>ICollection&lt;T&gt;</code> and <code>ISet&lt;T&gt;</code>.</p>
<h1 id="serializer">Serializer</h1>
<p>Bond serialization API is provided by the <code>Serializer</code> class. It is a generic class parameterized with type of protocol writer used for serialization:</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs">Serializer&lt;CompactBinaryWriter&lt;OutputStream&gt;&gt;</code></pre></td></tr></table></div>
<p>The constructor of the <code>Serializer</code> class takes the type of a class or struct representing Bond schema:</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs"><span class="kw">new</span> Serializer&lt;CompactBinaryWriter&lt;OutputStream&gt;&gt;(<span class="kw">typeof</span>(Record))</code></pre></td></tr></table></div>
<p>The constructor is non-trivial so application usually should create an instance of <code>Serializer</code> outside of the inner loop and reuse it.</p>
<p>The <code>Serializer</code> class exposes one public method <code>Serialize</code> which takes two arguments, an object to be serialized and an instance of the protocol writer to be used for serialization.</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs">serializer.<span class="fu">Serialize</span>(obj, writer);</code></pre></td></tr></table></div>
<p>The object’s type must be the same as the type passed to the <code>Serializer</code> constructor, otherwise the behaviour is undefined.</p>
<p>Bond provides a helper static API for applications that use schema types known at compile-time and don’t need to manage lifetime of the <code>Serializer</code>:</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs">Serialize.<span class="fu">To</span>(writer, obj);</code></pre></td></tr></table></div>
<p>When the API is called for the first time, a static instance of appropriate <code>Serializer</code> is created. Because of this the first call to the API for given type and protocol may take relatively long time. Subsequent calls for the same writer/object types reuse the static instance.</p>
<h1 id="deserializer">Deserializer</h1>
<p>Bond serialization API is provided by the <code>Deserializer</code> class. It is a generic class parameterized with type of the protocol reader to be used for deserialization:</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs">Deserializer&lt;CompactBinaryReader&lt;InputStream&gt;&gt;</code></pre></td></tr></table></div>
<p>The constructor of the <code>Deserializer</code> class takes the type of a class or struct representing Bond schema:</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs"><span class="kw">new</span> Deserializer&lt;CompactBinaryReader&lt;InputStream&gt;&gt;(<span class="kw">typeof</span>(Record))</code></pre></td></tr></table></div>
<p>The constructor is non-trivial so application usually should create an instance of <code>Deserializer</code> outside of the inner loop and reuse it.</p>
<p>The <code>Deserializer</code> class exposes one generic public method <code>Deserialize</code> which takes as an argument an instance of the protocol reader and returns a deserialized object:</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs"><span class="dt">var</span> record = deserializer.<span class="fu">Deserialize</span>&lt;Record&gt;(reader);</code></pre></td></tr></table></div>
<p>The object created by <code>Deserialize</code> is always of the type specified during <code>Deserializer</code> construction. The type parameter of the method is only used to cast the result.</p>
<p>Deserializing from payload encoded in an untagged protocol like Simple usually requires specifying schema of the payload. To address this scenario the <code>Deserializer</code> class has an additional constructor taking a <a href="#runtime-schema"><code>RuntimeSchema</code></a> as an argument:</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs">RuntimeSchema schema;
<span class="co">// ...</span>
<span class="dt">var</span> d = <span class="kw">new</span> Deserializer&lt;SimpleReader&lt;InputStream&gt;&gt;(<span class="kw">typeof</span>(Record), schema);
<span class="dt">var</span> obj = d.<span class="fu">Deserialize</span>&lt;Record&gt;(reader);</code></pre></td></tr></table></div>
<p>An instance of <code>Deserializer</code> created this way is tied to the triplet of protocol, object type and payload schema. In order to deserialize from payload in another schema a new instance of <code>Deserializer</code> needs to be created.</p>
<p>Bond provides a helper static API for applications that use schema types known at compile-time, don’t need to specify payload schema and don’t need to manage lifetime of the <code>Deserializer</code>:</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs"><span class="dt">var</span> obj = Deserialize&lt;Record&gt;.<span class="fu">From</span>(reader);</code></pre></td></tr></table></div>
<p>When an application calls this API for the first time, a static instance of appropriate <code>Deserializer</code> is created. Because of this the first call to the API for given type and protocol may take relatively long time. Subsequent calls for the same reader/object types reuse the static instance.</p>
<p>See also the following example:</p>
<ul>
<li><code>examples/cs/core/untagged_protocols</code></li>
</ul>
<h1 id="marshaling">Marshaling</h1>
<p>Since Bond supports multiple serialization <a href="bond_cpp.html#protocols">protocols</a>, application endpoints either have to agree on a particular protocol, or include protocol metadata in the payload. Marshaling APIs provide the standard way to do the latter, by automatically adding a payload header with the protocol identifier and version.</p>
<p><code>Marshal</code> and <code>Unmarshal</code> APIs are very similar to <code>Serialize</code> and <code>Deserialize</code>, except that when calling <code>Unmarshal</code> the application simply provides an input stream with payload data, rather than an instance of a particular protocol reader:</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs"><span class="dt">var</span> src = <span class="kw">new</span> Example
{
    Name = <span class="st">&quot;foo&quot;</span>,
    Constants = { <span class="fl">3.14</span>, <span class="fl">6.28</span> }
};

<span class="dt">var</span> output = <span class="kw">new</span> <span class="fu">OutputBuffer</span>();
<span class="dt">var</span> writer = <span class="kw">new</span> CompactBinaryWriter&lt;OutputBuffer&gt;(output);

Marshal.<span class="fu">To</span>(writer, src);

<span class="dt">var</span> input = <span class="kw">new</span> <span class="fu">InputBuffer</span>(output.<span class="fu">Data</span>);

<span class="dt">var</span> dst = Unmarshal&lt;Example&gt;.<span class="fu">From</span>(input);</code></pre></td></tr></table></div>
<p>See also the following example:</p>
<ul>
<li><code>examples/cs/core/marshaling</code></li>
</ul>
<h1 id="transcoder">Transcoder</h1>
<p>The <code>Transcoder</code> class provides API for converting payloads from one protocol into another. Transcoder operates directly on serialized data and doesn’t need to know the C# type representing payload schema.</p>
<p>The <code>Transcoder</code> is a generic class parameterized with types of source protocol reader and destination protocol writer, e.g.:</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs">Transcoder&lt;CompactBinaryReader&lt;InputStream&gt;, SimpleWriter&lt;OutputStream&gt;&gt;</code></pre></td></tr></table></div>
<p>The constructor of the <code>Transcoder</code> class takes as an optional argument the <a href="#runtime-schema">runtime schema</a> of the payload. The argument is optional when transcoding between tagged protocols but must be specified when transcoding from an untagged protocol or to a text protocol.</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs">RuntimeSchema schema;
<span class="co">// ...</span>
<span class="dt">var</span> t = <span class="kw">new</span> Transcoder&lt;&lt;SimpleReader&lt;InputStream&gt;, CompactBinaryWriter&lt;OutputStream&gt;&gt;(schema);</code></pre></td></tr></table></div>
<p>The <code>Transcoder</code> constructor is non-trivial so application usually should create an instance of <code>Transcoder</code> outside of the inner loop and reuse it.</p>
<p>The <code>Transcoder</code> class exposes one public method <code>Transcode</code> which takes two arguments, protocol reader representing payload to transcode from, and protocol writer to be used to write the result.</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs">t.<span class="fu">Transcode</span>(reader, writer);</code></pre></td></tr></table></div>
<p>Bond provides a static helper API for application that don’t need to explicitly manage <code>Transcoder</code> lifetime and don’t specify payload schema or use a schema known at compile-time:</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs"><span class="co">// transcoding w/o schema</span>
Transcode.<span class="fu">FromTo</span>(reader, writer);

<span class="co">// transcoding with compile-time schema Foo</span>
Transcode&lt;Foo&gt;.<span class="fu">FromTo</span>(reader, writer);</code></pre></td></tr></table></div>
<p>When an application calls this API for the first time, a static instance of appropriate <code>Transcoder</code> is created. Because of this the first call to the API for given type/schema and protocol may take relatively long time. Subsequent calls for the same reader/writer types reuse the static instance. Note that the static API can’t be used if source protocol is untagged and will result in runtime exception.</p>
<p>See also the following example:</p>
<ul>
<li><code>examples/cs/core/protocol_transcoding</code></li>
</ul>
<h1 id="input-and-output-streams">Input and output streams</h1>
<p>The input and output for binary protocols is provided by <code>IInputStream</code> and <code>IOutputStream</code> interfaces. Bond comes with standard implementations of these interfaces for memory buffers and <code>System.IO.Stream</code>, and applications can provide their own custom implementations.</p>
<p>The <code>OutputBuffer</code> class implements <code>IOutputStream</code> interface on top of a memory buffer. It comes in two variants. <code>Bond.IO.Safe.OutputBuffer</code> uses only safe managed code and is included in <code>Bond.dll</code> assembly which is compatible with Portable Class Library. <code>Bond.IO.Unsafe.OutputBuffer</code> uses unsafe code to optimize for performance. It is included in <code>Bond.IO.dll</code> assembly which requires full .NET runtime. Both implementations have identical class names and APIs, the only difference is the namespace in which they are defined.</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs"><span class="co">// Create an output buffer with initial size of 16KB</span>
<span class="dt">var</span> output = <span class="kw">new</span> <span class="fu">OutputBuffer</span>(<span class="dv">16</span> * <span class="dv">1024</span>);
<span class="dt">var</span> writer = <span class="kw">new</span> CompactBinaryWriter&lt;OutputBuffer&gt;(output);

Serialize.<span class="fu">To</span>(writer, obj);

<span class="co">// Get the serialized payload form the output buffer</span>
ArraySegment&lt;<span class="dt">byte</span>&gt; data = output.<span class="fu">Data</span>;</code></pre></td></tr></table></div>
<p>The <code>InputBuffer</code> class implements <code>IInputStream</code> interface on top of a memory buffer. Like <code>OutputBuffer</code> it comes in two flavors, the safe and portable <code>Bond.IO.Safe.OutputBuffer</code>, and the performance optimized via use of unsafe code <code>Bond.IO.Unsafe.OutputBuffer</code>.</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs"><span class="co">// Create an input buffer on top of a byte[]</span>
<span class="dt">var</span> input = <span class="kw">new</span> <span class="fu">InputBuffer</span>(byteArray);
<span class="dt">var</span> reader = <span class="kw">new</span> CompactBinaryReader&lt;InputBuffer&gt;(input);</code></pre></td></tr></table></div>
<p>The <code>InputStream</code> and <code>OutputStream</code> classes provide implementations of <code>IInputStream</code> and <code>IOutputStream</code> on top of <code>System.IO.Stream</code>. These classes are included in <code>Bond.IO.dll</code> and thus are only available to applications using full .NET runtime and allowing unsafe code. <code>In/OutputStream</code> can be used with any <code>Stream</code>, including <code>MemoryStream</code>, however aforementioned the <code>In/OutputBuffer</code> provide significantly better performance and are recommended when working with in-memory payloads.</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs"><span class="kw">using</span> (<span class="dt">var</span> stream = <span class="kw">new</span> <span class="fu">FileStream</span>(<span class="st">&quot;example.bin&quot;</span>, FileMode.<span class="fu">Open</span>))
{
    <span class="dt">var</span> input = <span class="kw">new</span> <span class="fu">InputStream</span>(stream);
    <span class="dt">var</span> reader = <span class="kw">new</span> CompactBinaryReader&lt;InputStream&gt;(input);
    <span class="dt">var</span> example = Deserialize&lt;Example&gt;.<span class="fu">From</span>(reader);
}</code></pre></td></tr></table></div>
<h1 id="cloner">Cloner</h1>
<p>The <code>Cloner</code> class provides API for deep cloning of objects representing Bond schemas. Unlike typical cloning, Bond <code>Cloner</code> is not limited to making clones that are of the same type as the source object. The type of the source and the clone merely need to represent compatible Bond schemas.</p>
<p>The <code>Cloner</code> is a generic class parameterized with the source type and its constructor takes one argument representing the type of clones to be created e.g.:</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs"><span class="dt">var</span> cloner = <span class="kw">new</span> Cloner&lt;Foo&gt;(<span class="kw">typeof</span>(Bar));</code></pre></td></tr></table></div>
<p>The constructor is non-trivial so application usually should create an instance of <code>Cloner</code> outside of the inner loop and reuse it.</p>
<p>The <code>Cloner</code> exposes one public, generic method <code>Clone</code> which takes as the argument the source object and returns a clone:</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs"><span class="dt">var</span> clone = cloner.<span class="fu">Clone</span>&lt;Bar&gt;(foo);</code></pre></td></tr></table></div>
<p>The object created by <code>Clone</code> is always of the type specified during <code>Cloner</code> construction. The type parameter of the method is only used to cast the result.</p>
<p>Bond provides a helper static API which creates and caches appropriate instance of <code>Cloner</code> the first time it is used, e.g.:</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs"><span class="dt">var</span> foo = <span class="kw">new</span> <span class="fu">Foo</span>();
<span class="dt">var</span> clone = Clone&lt;Bar&gt;.<span class="fu">From</span>(foo);</code></pre></td></tr></table></div>
<p>See also the following example:</p>
<ul>
<li><code>examples/cs/core/cloning</code></li>
</ul>
<h1 id="comparer">Comparer</h1>
<p>The <code>Comparer</code> class provides API for deep comparison for equality of objects representing Bond schemas. The class exposes one public, static, generic method <code>Equal</code> which takes two parameters representing objects to be compared.</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs"><span class="dt">var</span> left = <span class="kw">new</span> <span class="fu">Foo</span>();
<span class="dt">var</span> right = <span class="kw">new</span> <span class="fu">Foo</span>();

<span class="dt">bool</span> equal = Comparer.<span class="fu">Equal</span>(left, right);</code></pre></td></tr></table></div>
<p>Note that the <code>Comparer</code> doesn’t compare arbitrary C# objects, it compares instances of Bond schemas. Only fields/properties decorated with Bond <a href="#idattribute">attributes</a> and base classes/interface representing Bond <a href="#schemaattribute">schemas</a> are considered during comparison.</p>
<h1 id="performance">Performance</h1>
<p>Bond offers very fast serialization and deserialization. Here are some tips on how to achieve the best performance.</p>
<ol style="list-style-type: decimal">
<li><p>Explicitly create instances of <code>Serializer/Deserializer/Transcoder</code></p>
<p>Instead of using simplified APIs like <code>Serialize.To</code> and <code>Deserialize&lt;T&gt;.From</code> it is usually better to explicitly instantiate and cache appropriate <code>Serializer/Deserializer/Transcoder</code> objects. Creation of these objects involves generation and JIT’ing of specific code to handle the particular operation for a given schema type and protocol(s). This may take a relatively long time, especially for large schemas, and usually it is best to do it during program initialization. Once the object is created it can be reused repeatedly and calling the Serialize/Deserialize/Transcode methods will be very fast.</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs"><span class="dt">var</span> exampleSerializer = <span class="kw">new</span> Serializer&lt;CompactBinaryWriter&lt;OutputBuffer&gt;&gt;(<span class="kw">typeof</span>(Example));
<span class="dt">var</span> exampleDeserializer = <span class="kw">new</span> Deserializer&lt;CompactBinaryReader&lt;InputBuffer&gt;&gt;(<span class="kw">typeof</span>(Example));

<span class="dt">var</span> output = <span class="kw">new</span> <span class="fu">OutputBuffer</span>();
<span class="dt">var</span> writer = <span class="kw">new</span> CompactBinaryWriter&lt;OutputBuffer&gt;(output);

exampleSerializer.<span class="fu">Serialize</span>(src, writer);

<span class="dt">var</span> input = <span class="kw">new</span> <span class="fu">InputBuffer</span>(output.<span class="fu">Data</span>);
<span class="dt">var</span> reader = <span class="kw">new</span> CompactBinaryReader&lt;InputBuffer&gt;(input);

<span class="dt">var</span> dst = exampleDeserializer.<span class="fu">Deserialize</span>&lt;Example&gt;(reader);</code></pre></td></tr></table></div>
<p>Note that the type of <code>Serializer/Deserializer</code> doesn’t depend on the schema type so it is easy to cache these objects for multiple schemas used in an application:</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs"><span class="dt">var</span> serializerCache = <span class="kw">new</span> Dictionary&lt;Type, Serializer&lt;CompactBinaryWriter&lt;OutputBuffer&gt;&gt;&gt;
    {
        {
            <span class="kw">typeof</span>(Foo),
            <span class="kw">new</span> Serializer&lt;CompactBinaryWriter&lt;OutputBuffer&gt;&gt;(<span class="kw">typeof</span>(Foo))
        },
        {
            <span class="kw">typeof</span>(Bar),
            <span class="kw">new</span> Serializer&lt;CompactBinaryWriter&lt;OutputBuffer&gt;&gt;(<span class="kw">typeof</span>(Bar))
        }
    };</code></pre></td></tr></table></div></li>
<li><p>Prefer <code>InputBuffer</code> and <code>OutputBuffer</code> over <code>MemoryStream</code></p>
<p>When working with Bond payloads in a memory buffer (<code>byte[]</code> or <code>ArraySegment&lt;byte&gt;</code>) Bond-defined <code>InputBuffer</code> and <code>OutputBuffer</code> classes will provide significantly better performance than <code>InputStream</code> and <code>OutputStream</code> used together with <code>System.MemoryStream</code>.</p>
<p><code>OutputBuffer</code> by default preallocates 64 KB of memory. When serializing small objects the cost of allocating and zeroing the memory may dominate the actual cost of serialization. Conversely, when serializing very large objects the initial buffer of 64KB may be too small, leading to unnecessary reallocations and memory copying.</p>
<p>The <code>OutputBuffer</code> constructor accepts an argument specifying the size of initial buffer in bytes. For optimal performance the size should be set to be a little bigger than expect size of serialized data.</p></li>
<li><p>Prefer <code>using Bond.IO.Unsafe;</code> over <code>using Bond.IO.Safe;</code></p>
<p>Bond defines two variants of <code>InputBuffer</code> and <code>OutputBuffer</code> in two namespaces <code>Bond.IO.Safe</code> and <code>Bond.IO.Unsafe</code>. The classes have identical interface and can be used interchangeably. The only difference is that the latter uses some low level memory access constructs and is implemented in <code>Bond.IO.dll</code> assembly which is compiled with <code>/unsafe</code> flag. The unsafe version is faster.</p></li>
<li><p>Pool memory buffers</p>
<p>Creating a new <code>InputBuffer</code>/<code>OutputBuffer</code> every time may be more costly than the actual serialization or deserialization and it increases GC pressure. Whenever possible pool and reuse buffers, simply resetting their position after or before use:</p>
<pre><code>buffer.Position = 0;</code></pre></li>
</ol>
<h1 id="runtime-schema">Runtime schema</h1>
<p>Some generic applications may need to work with Bond schemas unknown at compile-time. In order to address such scenarios Bond defines a type <code>SchemaDef</code> to represent schemas at runtime. Applications can obtain an instance of <code>SchemaDef</code> for a particular type using the <code>Schema</code> class:</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs"><span class="co">// from a type T</span>
<span class="dt">var</span> schema = Schema&lt;T&gt;.<span class="fu">RuntimeSchema</span>;

<span class="co">// from type of an object</span>
<span class="dt">var</span> schema = Schema.<span class="fu">GetRuntimeSchema</span>(<span class="kw">typeof</span>(obj));</code></pre></td></tr></table></div>
<p>The APIs return an object of type <code>RuntimeSchema</code>, which is a thin wrapper over <code>SchemaDef</code>. Access to underlying schema is provided via public properties:</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs"><span class="dt">var</span> schemaDef = schema.<span class="fu">SchemaDef</span></code></pre></td></tr></table></div>
<p>The <code>SchemaDef</code> object is always self contained, including the runtime schema definitions for all nested types (if any). The <code>RuntimeSchema</code> class instance can be constructed from a <code>SchemaDef</code>, and then it represents the whole schema, or from any embedded <code>TypeDef</code>:</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs"><span class="co">// runtime schema of Foo</span>
<span class="dt">var</span> schema = Schema&lt;Foo&gt;.<span class="fu">RuntimeSchema</span>;

<span class="co">// runtime schema of the first field of Foo</span>
<span class="dt">var</span> fieldSchema = <span class="kw">new</span> <span class="fu">RuntimeSchema</span>(schema, schema.<span class="fu">StructDef</span>.<span class="fu">fields</span>[<span class="dv">0</span>].<span class="fu">type</span>);</code></pre></td></tr></table></div>
<p><code>SchemaDef</code> is a Bond type, defined in <code>bond.bond</code>, and as such can be de/serialized like any other Bond type:</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs">Serialize.<span class="fu">To</span>(writer, Schema&lt;T&gt;.<span class="fu">RuntimeSchema</span>.<span class="fu">SchemaDef</span>);</code></pre></td></tr></table></div>
<p>See also the following example:</p>
<ul>
<li><code>examples/cs/core/runtime_schema</code></li>
</ul>
<h1 id="understanding-bondedt">Understanding <code>bonded&lt;T&gt;</code></h1>
<p>The generic type <code>bonded&lt;T&gt;</code> is a simple yet powerful abstraction which is a fundamental part of Bond APIs and enables such usage scenarios as lazy deserialization, pass-through and polymorphism.</p>
<p>In C# <code>bonded&lt;T&gt;</code> maps to <code>IBonded&lt;T&gt;</code> interface which supports three operations: <code>Serialize</code>, <code>Deserialize</code> and <code>Convert</code>. Bond provides two standard implementation of the <code>IBonded&lt;T&gt;</code> interface, <code>Bonded&lt;T&gt;</code> which can hold and instance of type <code>T</code>, and <code>Bonded&lt;T, R&gt;</code> which can hold a serialized payload represented by a protocol reader <code>R</code>. The former is usually used by producers to initialize <code>bonded&lt;T&gt;</code> values, the latter is implicitly used during deserialization.</p>
<h2 id="lazy-deserialization">Lazy deserialization</h2>
<p>Because <code>bonded&lt;T&gt;</code> can store (or more accurately, refer to) data representing a serialized data, it can be used to de facto delay deserialization of some parts of payload:</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs"><span class="kw">struct</span> Example
{
    <span class="dv">0</span>: Always always;
    <span class="dv">1</span>: bonded&lt;Sometimes&gt; sometimes;
}</code></pre></td></tr></table></div>
<p>The schema defined above contains two nested fields. When an object of type <code>Example</code> is deserialized, the field <code>always</code> will be fully instantiated and deserialized, but field <code>sometimes</code>, which is declared as <code>bonded&lt;Sometimes&gt;</code>, will be merely initialized with a reference to its serialized representation. Application can then deserialize the object only when needed:</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs"><span class="dt">var</span> example = Deserialize&lt;Example&gt;.<span class="fu">From</span>(reader);

<span class="co">// Deserialize sometimes only when needed</span>
<span class="kw">if</span> (needSometimes)
{
    <span class="dt">var</span> sometimes = example.<span class="fu">sometimes</span>.<span class="fu">Deserialize</span>();
}</code></pre></td></tr></table></div>
<h2 id="pass-through">Pass-through</h2>
<p>When <code>bonded&lt;T&gt;</code> containing a payload is serialized all the field from the original payload are preserved. This property very useful when building multi-stage service pipelines. Intermediary nodes often need to pass data through with full fidelity. At the same time, it is desirable that every schema change doesn’t necessitate redeployment of all the nodes in a pipeline. Using <code>bonded&lt;T&gt;</code> for pass-through is often the right solution.</p>
<p>As an example let’s imagine a simple aggregator which receives responses from upstream services and aggregates top results.</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs"><span class="kw">struct</span> Upstream
{
    <span class="dv">0</span>: bonded&lt;Response&gt; response;
    <span class="dv">1</span>: <span class="dt">float</span> ranking;
}

<span class="kw">struct</span> Aggregated
{
    <span class="dv">0</span>: list&lt;bonded&lt;Response&gt;&gt; responses;
}</code></pre></td></tr></table></div>
<p>Using <code>bonded&lt;Response&gt;</code> allows the intermediary to aggregate responses, preserving their full content, even if the aggregator doesn’t use the same version of the <code>Response</code> schema as the upstream.</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs"><span class="dt">void</span> <span class="fu">ProcessResponse</span>(Upstream upstream)
{
    <span class="kw">if</span> (upstream.<span class="fu">ranking</span> &gt; threshold)
    {
        aggregated.<span class="fu">responses</span>.<span class="fu">Add</span>(upstream.<span class="fu">response</span>);
    }
}</code></pre></td></tr></table></div>
<h2 id="polymorphism">Polymorphism</h2>
<p>The type parameter <code>T</code> in <code>IBonded&lt;T&gt;</code> interface is covariant which enables polymorphism. A <code>IBonded&lt;Base&gt;</code> can be initialized with an instance of <code>Bonded&lt;Derived&gt;</code>. For example, given the following schema:</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs"><span class="kw">enum</span> Kind
{
    rectangle,
    circle,
    none
}

<span class="kw">struct</span> Shape
{
    <span class="dv">0</span>: Kind kind = none;
}

<span class="kw">struct</span> Rectangle: Shape
{
    <span class="dv">0</span>: int32 width;
    <span class="dv">1</span>: int32 height;
}

<span class="kw">struct</span> Circle : Shape
{
    <span class="dv">0</span>: int32 radius;
}

<span class="kw">struct</span> Example
{
    <span class="dv">0</span>: vector&lt;bonded&lt;Shape&gt;&gt; shapes;
}</code></pre></td></tr></table></div>
<p>The type of the <code>shapes</code> field in C# class <code>Example</code> will be <code>List&lt;IBonded&lt;Shape&gt;&gt;</code> and an instance of the <code>Example</code> can be initialized as following:</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs"><span class="dt">var</span> src = <span class="kw">new</span> Example
{
    shapes = 
    {
        <span class="kw">new</span> Bonded&lt;Circle&gt;(<span class="kw">new</span> Circle {kind = Kind.<span class="fu">circle</span>, radius = <span class="dv">10</span>),
        <span class="kw">new</span> Bonded&lt;Rectangle&gt;(<span class="kw">new</span> Rectangle {kind = Kind.<span class="fu">rectangle</span>, width = <span class="dv">4</span>, height = <span class="dv">5</span>)
    }
};</code></pre></td></tr></table></div>
<p>See also the following example:</p>
<ul>
<li><code>examples/cs/core/polymorphic_container</code></li>
</ul>
<h1 id="custom-type-mappings">Custom type mappings</h1>
<p>Bond codegen provides a simple extensibility mechanism allowing use of custom C# types to represent types in a Bond schema. One common scenario is replacing the default collections with a different implementation that is semantically identical, e.g. <code>SortedSet&lt;T&gt;</code> instead of <code>HashSet&lt;T&gt;</code>. Custom type mappings can be also used to introduce completely new types which can be serialized as one of the built-in Bond schema types. For example time could be represented using the <code>DateTime</code> class and serialized as <code>int64</code>.</p>
<p>Defining a custom type mapping involves three steps:</p>
<ul>
<li>Define a <a href="compiler.html#type-aliases">type alias</a> in the schema.</li>
<li>Specify during codegen a C# type to represent the alias.</li>
<li>Implement an appropriate converter for the custom C# type.</li>
</ul>
<h2 id="codegen-parameters">Codegen parameters</h2>
<p>When generating code for a schema that uses <a href="compiler.html#type-aliases">type aliases</a>, the user can specify a custom type to represent each alias in the generated code:</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs">gbc c# --<span class="kw">using</span>=<span class="st">&quot;DateTime=System.DateTime&quot;</span> date_time.<span class="fu">bond</span></code></pre></td></tr></table></div>
<p>The value of the <code>/using</code> parameter consists of one or more alias substitutions separated by semicolons, each in the following format:</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs">alias-name=generated-type-name</code></pre></td></tr></table></div>
<h2 id="custom-containers">Custom containers</h2>
<p>Type aliases of container types can be mapped to user defined collection classes as long as they implement the same interfaces as the default collections: <code>IEnumerable&lt;T&gt;</code> as well as <code>ICollection&lt;T&gt;</code> for aliases of <code>list&lt;T&gt;</code> and <code>vector&lt;T&gt;</code>, <code>ISet&lt;T&gt;</code> for aliases of <code>set&lt;T&gt;</code> and <code>IDictionary&lt;K, V&gt;</code> for aliases of <code>map&lt;K ,V&gt;</code>. Custom mappings of container type aliases don’t require a user defined converter.</p>
<ul>
<li><code>examples/cs/core/container_alias</code></li>
</ul>
<h2 id="converter">Converter</h2>
<p>Applications using custom mappings for aliases of scalar types, string or blob must provide converter between the custom type and the default type. The converter is a public class named <code>BondTypeAliasConverter</code> defining a pair of public static <code>Convert</code> methods for each type alias:</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs"><span class="kw">public</span> <span class="kw">static</span> CustomType <span class="fu">Convert</span>(AliasedType value, CustomType unused)
<span class="kw">public</span> <span class="kw">static</span> AliasedType <span class="fu">Convert</span>(CustomType value, AliasedType unused)</code></pre></td></tr></table></div>
<p>For example if <code>System.DateTime</code> was mapped to an alias of <code>int64</code> the following class could be defined to provide conversions between <code>DateTime</code> and <code>long</code> (the default type for <code>int64</code>):</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs"><span class="kw">public</span> <span class="kw">static</span> <span class="kw">class</span> BondTypeAliasConverter
{
    <span class="kw">public</span> <span class="kw">static</span> <span class="dt">long</span> <span class="fu">Convert</span>(DateTime value, <span class="dt">long</span> unused)
    {
        <span class="kw">return</span> value.<span class="fu">Ticks</span>;
    }

    <span class="kw">public</span> <span class="kw">static</span> DateTime <span class="fu">Convert</span>(<span class="dt">long</span> value, DateTime unused)
    {
        <span class="kw">return</span> <span class="kw">new</span> <span class="fu">DateTime</span>(value);
    }
}</code></pre></td></tr></table></div>
<p>The converter class must be defined in the same assembly and namespace as the class representing the Bond schema(s) in which the type alias is used or assembly/namespace of one of the types being converted.</p>
<ul>
<li><code>examples/cs/core/date_time</code></li>
<li><code>examples/cs/core/decimal</code></li>
<li><code>examples/cs/core/guid</code></li>
</ul>
<h1 id="xml">Xml</h1>
<p>Bond supports Xml serialization via Simple Xml protocol implemented by the <code>SimpleXmlReader</code> and <code>SimpleXmlWriter</code> classes:</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs"><span class="dt">var</span> stream = <span class="kw">new</span> System.<span class="fu">IO</span>.<span class="fu">MemoryStream</span>();
<span class="dt">var</span> writer = <span class="kw">new</span> <span class="fu">SimpleXmlWriter</span>(stream);

Serialize.<span class="fu">To</span>(writer, src);

output.<span class="fu">Flush</span>();
stream.<span class="fu">Position</span> = <span class="dv">0</span>;

<span class="dt">var</span> reader = <span class="kw">new</span> <span class="fu">SimpleXmlReader</span>(stream);

<span class="dt">var</span> dst = Deserialize&lt;Record&gt;.<span class="fu">From</span>(reader);</code></pre></td></tr></table></div>
<p>In the example above the Xml reader and writer are constructed directly from an instance of <code>System.Stream</code>. Underneath however they use <code>System.Xml.XmlReader</code> and <code>System.Xml.XmlWriter</code> which provide fast, non-cached, forward-only Xml parsing and generation on top of many different data readers and writers. For example to deserialize Xml payload from a string:</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs">var xmlString = <span class="st">&quot;&lt;Record&gt;&lt;Name&gt;test&lt;/Name&gt;&lt;Numbers&gt;&lt;Item&gt;3.14&lt;/Item&gt;&lt;/Numbers&gt;&lt;/Record&gt;&quot;</span>;

<span class="dt">var</span> reader = <span class="kw">new</span> <span class="fu">SimpleXmlReader</span>(XmlReader.<span class="fu">Create</span>(<span class="kw">new</span> <span class="fu">StringReader</span>(xmlString)));
<span class="dt">var</span> record = Deserialize&lt;Record&gt;.<span class="fu">From</span>(reader);</code></pre></td></tr></table></div>
<p>The Simple Xml protocol flattens the inheritance hierarchy, putting fields from base and derived classes together under a single element. In order to prevent name conflicts, Simple Xml protocol provides support for optional use of fully qualified schema names as field element namespaces, e.g.:</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs">&lt;Derived xmlns:b=<span class="st">&quot;urn:Examples.Base&quot;</span> xmlns:d=<span class="st">&quot;urn:Examples.Derived&quot;</span>&gt;
    &lt;d:Field&gt;<span class="dv">10</span>&lt;/d:Field&gt;
    &lt;b:Field&gt;foo&lt;/b:Field&gt;
&lt;/Derived&gt;</code></pre></td></tr></table></div>
<p>Namespaces can be enabled when serializing to Xml via the <code>UseNamespaces</code> flag in SimpleXmlWriter.Settings:</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs"><span class="dt">var</span> writer = <span class="kw">new</span> <span class="fu">SimpleXmlWriter</span>(stream, <span class="kw">new</span> SimpleXmlWriter.<span class="fu">Settings</span> 
{
    UseNamespaces = <span class="kw">true</span>
});</code></pre></td></tr></table></div>
<p>There is no need to enable namespace support for the SimpleXmlReader. The elements representing fields are always matched against field names and their namespaces, if specified in the Xml document, against the qualified names of the containing structs.</p>
<p>Using Xml namespace inherently limits some of flexibility of Bond deserialization. In particular a document with namespaces can’t be deserialized into a schema that is compatible but has a different name, for example a <a href="compiler.html#struct-views">view</a> of the payload schema.</p>
<p>See also the following example:</p>
<ul>
<li><code>examples/cs/core/simple_xml</code></li>
</ul>
<h1 id="json">JSON</h1>
<p>Bond supports JSON serialization via the Simple JSON protocol implemented by the <code>SimpleJsonReader</code> and <code>SimpleJsonWriter</code> classes. The JSON protocol depends on the Newtonsoft JSON parser and the classes are in a separate assembly <code>Bond.JSON.dll</code>.</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs"><span class="dt">var</span> stream = <span class="kw">new</span> System.<span class="fu">IO</span>.<span class="fu">MemoryStream</span>();
<span class="dt">var</span> writer = <span class="kw">new</span> <span class="fu">SimpleJsonWriter</span>(stream);

Serialize.<span class="fu">To</span>(writer, src);

output.<span class="fu">Flush</span>();
stream.<span class="fu">Position</span> = <span class="dv">0</span>;

<span class="dt">var</span> reader = <span class="kw">new</span> <span class="fu">SimpleJsonReader</span>(stream);

<span class="dt">var</span> dst = Deserialize&lt;Record&gt;.<span class="fu">From</span>(reader);</code></pre></td></tr></table></div>
<p>In the example above the JSON reader and writer are constructed directly from an instance of <code>System.Stream</code>. Alternatively they can be also constructed from <code>System.IO.TextReader</code> and <code>System.IO.TextWriter</code>. For example to deserialize JSON payload from a string:</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs">var jsonString = <span class="st">&quot;{Name: test, Numbers: [3.14]}&quot;</span>;

<span class="dt">var</span> reader = <span class="kw">new</span> <span class="fu">SimpleJsonReader</span>(<span class="kw">new</span> <span class="fu">StringReader</span>(jsonString));
<span class="dt">var</span> record = Deserialize&lt;Record&gt;.<span class="fu">From</span>(reader);</code></pre></td></tr></table></div>
<p>The Simple JSON protocol flattens the inheritance hierarchy, putting fields from base and derived schemas together in the same JSON object. Name conflicts in the JSON representation between fields of base and derived schema can be resolved using <code>JsonName</code> schema field attribute:</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs"><span class="kw">struct</span> Base
{
    <span class="dv">0</span>: <span class="dt">string</span> name;
}

<span class="kw">struct</span> Derived : Base
{
    [<span class="fu">JsonName</span>(<span class="st">&quot;DerivedName&quot;</span>)]
    <span class="dv">0</span>: <span class="dt">string</span> name;
}</code></pre></td></tr></table></div>
<p>See also the following example:</p>
<ul>
<li><code>examples/cs/core/simple_json</code></li>
</ul>
<h1 id="attributes">Attributes</h1>
<p>Bond defines several attributes which are used to decorate user defined types with extra information required by Bond.</p>
<h2 id="schema-decoration">Schema decoration</h2>
<p>User defined types that represent Bond schemas and their members are decorated with following attributes.</p>
<h3 id="schemaattribute">SchemaAttribute</h3>
<p>The <code>Schema</code> attribute is used to mark types that represent Bond schemas and thus can be used with Bond APIs. The attribute can be applied to classes, structs and interfaces.</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs">[Bond.<span class="fu">Schema</span>]
<span class="kw">public</span> <span class="kw">class</span> Foo {}

[Bond.<span class="fu">Schema</span>]
<span class="kw">public</span> <span class="kw">struct</span> Bar {}

[Bond.<span class="fu">Schema</span>]
<span class="kw">public</span> <span class="kw">interface</span> IFoo {}</code></pre></td></tr></table></div>
<p>The <code>Schema</code> attribute applies to the specific type only and is not inherited. When a class decorated with the <code>Schema</code> attribute derives from another class also decorated with the attribute then it represents Bond schema hierarchy. When a class representing schema derives from a class that is not marked with the <code>Schema</code> attribute then it represents a simple schema without a base, the C# base class is ignored by Bond.</p>
<p>When a C# class/interfaces representing a schema derives from multiple interfaces, at most one can be an interface representing a schema (i.e. decorated with <code>[Schema]</code> attribute).</p>
<h3 id="namespaceattribute">NamespaceAttribute</h3>
<p>The <code>Namespace</code> attribute can be optionally used to annotate C# classes, interfaces and enums if their C# namespace is different than the schema namespace (i.e. namespace in .bond idl file), for example when C# code is generated with <code>--namespace</code> flag.</p>
<p>Bond will use the <code>Namespace</code> attribute, when present, to create qualified name of the type. If the attribute is absent the qualified name will use the C# namespace in which the type is defined.</p>
<h3 id="idattribute">IdAttribute</h3>
<p>All public fields and properties that represents fields of a Bond schema must be decorated with the <code>Id</code> attribute to specify the field’s identifier (also called field ordinal). The ordinal value must an unsigned 16-bit integer, unique for each field within a type.</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs">[Bond.<span class="fu">Schema</span>]
<span class="kw">public</span> <span class="kw">class</span> Foo
{
    [Bond.<span class="fu">Id</span>(<span class="dv">0</span>)]
    <span class="kw">public</span> <span class="dt">string</span> message { <span class="kw">get</span>; <span class="kw">set</span>; }
}</code></pre></td></tr></table></div>
<p>A type representing a schema may have additional fields/properties that don’t represent schema fields and thus are not decorated with Bond attributes.</p>
<h3 id="requiredattribute">RequiredAttribute</h3>
<p>By default fields of Bond schemas are optional. <a href="bond_cpp.html#required-fields">Required fields</a> must be marked with the <code>Required</code> attribute.</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs"><span class="co">/* Bond schema</span>
<span class="co">struct Foo</span>
<span class="co">{</span>
<span class="co">    0: required string message;</span>
<span class="co">}</span>
<span class="co">*/</span>
[Bond.<span class="fu">Schema</span>]
<span class="kw">public</span> <span class="kw">class</span> Foo
{
    [Bond.<span class="fu">Id</span>(<span class="dv">0</span>), Bond.<span class="fu">Required</span>]
    <span class="kw">public</span> <span class="dt">string</span> message { <span class="kw">get</span>; <span class="kw">set</span>; }
}</code></pre></td></tr></table></div>
<h3 id="typeattribute">TypeAttribute</h3>
<p>The <code>Type</code> attribute is used to provide additional type information about schema fields. The attribute is optional because in most cases Bond can infer type from the C# type of field/property. For example C# type <code>short</code> always maps to Bond type <code>int16</code>. However not all C# types have an unambiguous mapping to Bond type system. For example C# <code>string</code> can represent either Bond type <code>string</code> or <code>wstring</code>. Similarly C# reference types which are always <em>nullable</em> can represent both <em>nullable</em> and <em>non-nullable</em> type in Bond schema. One of the uses for the <code>Type</code> is resolving such ambiguities.</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs"><span class="kw">using</span> Bond.<span class="fu">Tag</span>;

<span class="co">/* Bond schema</span>
<span class="co">struct Foo</span>
<span class="co">{</span>
<span class="co">    0: nullable&lt;wstring&gt; str1;</span>
<span class="co">    1: string str2 = nothing;</span>
<span class="co">} </span>
<span class="co">*/</span>
[Bond.<span class="fu">Schema</span>]
<span class="kw">public</span> <span class="kw">class</span> Foo
{
    [Bond.<span class="fu">Id</span>(<span class="dv">0</span>), Bond.<span class="fu">Type</span>(<span class="kw">typeof</span>(nullable&lt;wstring&gt;))]
    <span class="kw">public</span> <span class="dt">string</span> str1 = <span class="kw">null</span>;

    [Bond.<span class="fu">Id</span>(<span class="dv">1</span>)]
    <span class="kw">public</span> <span class="dt">string</span> str2 = <span class="kw">null</span>;
}</code></pre></td></tr></table></div>
<p>Bond defines the following tag types that can be used in a <code>Type</code> attribute: - <code>nullable</code>: specifies that a reference or nullable C# type represents a <em>nullable</em> type in the Bond type system. - <code>wstring</code>: specifies that a string is UTF16 (i.e. <code>wstring</code> in the Bond type system). - <code>blob</code>: specifies that the type represents the schema type <code>blob</code>.</p>
<p>The <code>Type</code> attribute can also be used to specify type of object to be created during deserialization when a field/property type is an interface.</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs">[Bond.<span class="fu">Schema</span>]
<span class="kw">public</span> <span class="kw">class</span> Foo
{
    [Bond.<span class="fu">Id</span>(<span class="dv">0</span>), Bond.<span class="fu">Type</span>(<span class="kw">typeof</span>(SortedSet&lt;<span class="dt">string</span>&gt;))]
    <span class="kw">public</span> ISet&lt;<span class="dt">string</span>&gt; strings1 { <span class="kw">get</span>; <span class="kw">set</span>; }

    [Bond.<span class="fu">Id</span>(<span class="dv">1</span>), Bond.<span class="fu">Type</span>(<span class="kw">typeof</span>(HashSet&lt;<span class="dt">string</span>&gt;))]
    <span class="kw">public</span> ISet&lt;<span class="dt">string</span>&gt; strings2 { <span class="kw">get</span>; <span class="kw">set</span>; }
}</code></pre></td></tr></table></div>
<h3 id="defaultattribute">DefaultAttribute</h3>
<p>Bond infers default field values for classes and structs representing schemas from the field initializers or the class/struct constructor. For interfaces the default field values must be specified explicitly by decorating the interface properties with the <code>Default</code> attribute. The value specified in the attribute must be compatible with the field type, otherwise the behaviour is undefined.</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs">[Bond.<span class="fu">Schema</span>]
<span class="kw">public</span> <span class="kw">interface</span> IFoo
{
    [Bond.<span class="fu">Id</span>(<span class="dv">0</span>), <span class="fu">Default</span>(<span class="st">&quot;default value&quot;</span>)]
    <span class="kw">public</span> <span class="dt">string</span> { <span class="kw">get</span>; <span class="kw">set</span>; }

    [Bond.<span class="fu">Id</span>(<span class="dv">0</span>), <span class="fu">Default</span>(<span class="fl">3.</span>14f)]
    <span class="kw">public</span> <span class="dt">float</span> { <span class="kw">get</span>; <span class="kw">set</span>; }
}</code></pre></td></tr></table></div>
<p>The <code>Default</code> attribute is optional for properties that are decorated with <code>nullable</code> tag (the default is implicitly <code>null</code>). For non-nullable collections the <code>Default</code> attribute can either specify <code>null</code>, which means default of <code>nothing</code> in the schema, or it can be omitted, which means the default is an empty collection. Non-nullable properties of a type representing a schema have no concept of a default value thus the <code>Default</code> attribute is not applicable.</p>
<h3 id="attributeattribute">AttributeAttribute</h3>
<p>The <code>Attribute</code> attribute can be used to specify user defined attribute(s) for schemas, fields and enums.</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs">[Bond.<span class="fu">Schema</span>]
[Bond.<span class="fu">Attribute</span>(<span class="st">&quot;name&quot;</span>, <span class="st">&quot;value&quot;</span>)]
<span class="kw">public</span> <span class="kw">class</span> Foo
{
    [Bond.<span class="fu">Id</span>(<span class="dv">0</span>)]
    [Bond.<span class="fu">Attribute</span>(<span class="st">&quot;custom1&quot;</span>, <span class="st">&quot;value1&quot;</span>)]
    [Bond.<span class="fu">Attribute</span>(<span class="st">&quot;custom2&quot;</span>, <span class="st">&quot;value2&quot;</span>)]
    <span class="kw">public</span> <span class="dt">string</span> foo;
}</code></pre></td></tr></table></div>
<p>Schema attributes are usually used by transforms to customize code generation but they can also be accessed by applications via reflection.</p>
<h2 id="protocol-decoration">Protocol decoration</h2>
<p>Bond defines several attributes that are used to decorate implementation of custom protocols with extra information.</p>
<h3 id="readerattribute">ReaderAttribute</h3>
<p>The <code>Reader</code> attribute is used on a protocol writer implementation and specifies the type that implements the reader for that protocol.</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs">[Bond.<span class="fu">Reader</span>(<span class="kw">typeof</span>(SimpleXmlReader))]
<span class="kw">public</span> <span class="kw">struct</span> SimpleXmlWriter : IProtocolWriter
{
    <span class="co">// ...</span>
}</code></pre></td></tr></table></div>
<h3 id="parserattribute">ParserAttribute</h3>
<p>The <code>Parser</code> attribute can be used on a protocol reader implementation and specifies the type of parser to be used for the protocol. It is optional for protocols that implement <code>IUntaggedReader</code> or <code>ITaggedReader</code> because they implicitly default to use <code>UntaggedParser</code> and <code>TaggedParser</code> respectively. When specified, the <code>Parser</code> attribute value must be a generic type definition with one type parameter, it must implement <code>IParser</code> interface and have two public constructors, one accepting <code>RuntimeSchema</code> argument and one accepting <code>Type</code> argument (compile-time schema).</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs">[Bond.<span class="fu">Parser</span>(<span class="kw">typeof</span>(SimpleXmlParser&lt;&gt;))]
<span class="kw">public</span> <span class="kw">struct</span> SimpleXmlReader : IXmlReader
{
    <span class="co">// ...</span>
}

<span class="kw">public</span> <span class="kw">class</span> SimpleXmlParser&lt;R&gt; : IParser
{
    <span class="fu">SimpleXmlParser</span>(RuntimeSchema schema)
    {
        <span class="co">// ...</span>
    }

    <span class="fu">SimpleXmlParser</span>(Type schema)
    {
        <span class="co">// ...</span>
    }
}</code></pre></td></tr></table></div>
<h3 id="serializerattribute">SerializerAttribute</h3>
<p>The <code>Serializer</code> attribute can be used on a protocol writer implementation to specify custom serializer for the writer. If the attribute is not specified then the default serializer implementation is used. The value of <code>Serializer</code> attribute must be a generic type definition with two type parameters <code>R</code> and <code>W</code>, it must implement <code>ISerializerGenerator&lt;R, W&gt;</code> interface and define two public constructors:</p>
<div class="sourceCode"><table class="sourceCode cs numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="sourceCode"><pre><code class="sourceCode cs">[Bond.<span class="fu">Serializer</span>(<span class="kw">typeof</span>(CustomSerializer&lt;,&gt;))]
<span class="kw">public</span> <span class="kw">struct</span> SimpleXmlWriter : IProtocolWriter
{
    <span class="co">// ...</span>
}

<span class="kw">public</span> <span class="kw">class</span> CustomSerializer&lt;R, W&gt; : ISerializerGenerator&lt;R, W&gt;
{
    <span class="kw">public</span> <span class="fu">CustomSerializer</span>(Expression&lt;Action&lt;R, W, <span class="dt">int</span>&gt;&gt; deferredSerialize, RuntimeSchema schema)
    {
        <span class="co">// ...</span>
    }

    <span class="kw">public</span> <span class="fu">CustomSerializer</span>(Expression&lt;Action&lt;R, W, <span class="dt">int</span>&gt;&gt; deferredSerialize, Type type)
    {
        <span class="co">// ...</span>
    }
}</code></pre></td></tr></table></div>
<h1 id="references">References</h1>
<h2 id="bond-compiler-referencecompiler"><a href="compiler.html">Bond compiler reference</a></h2>
<h2 id="c-users-manualbond_cpp"><a href="bond_cpp.html">C++ User’s Manual</a></h2>
<h2 id="python-users-manualbond_py"><a href="bond_py.html">Python User’s Manual</a></h2>
</div>    
</div>
</body>
</html>
